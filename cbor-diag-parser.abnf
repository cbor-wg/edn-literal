seq             = S [item S *("," S item S) OC] S
one-item        = S item S
item            = map / array / tagged
                / number / simple
                / string / streamstring

string1         = (tstr / bstr) spec
string1e        = string1 / ellipsis
ellipsis        = 3*"." ; "..." or more dots
string          = string1e *(S string1e)

number          = (basenumber / decnumber / infin) spec
sign            = "+" / "-"
decnumber       = [sign] (1*DIGIT ["." *DIGIT] / "." 1*DIGIT)
                         ["e" [sign] 1*DIGIT]
basenumber      = [sign] "0" ("x" 1*HEXDIG
                              [["." *HEXDIG] "p" [sign] 1*DIGIT]
                            / "x" "." 1*HEXDIG "p" [sign] 1*DIGIT
                            / "o" 1*ODIGIT
                            / "b" 1*BDIGIT)
infin           = %s"Infinity"
                / %s"-Infinity"
                / %s"NaN"
simple          = %s"false"
                / %s"true"
                / %s"null"
                / %s"undefined"
                / %s"simple(" S item S ")"
uint            = "0" / DIGIT1 *DIGIT
tagged          = uint spec "(" S item S ")"

app-prefix      = lcalpha *lcalnum ; including h and b64
                / ucalpha *ucalnum ; tagged variant, if defined
sqstr           = "'" *single-quoted "'"
bstr            = embedded / sqstr / known-app-str / ext-app-str
ext-app-str     = app-prefix sqstr
known-app-str   = h / b64 / ip / dt

invalid-app-str = *single-quoted ; error parsing the grammar of this app-str

; app-string h
h               = %s"h" SQUOTE inside-h SQUOTE
inside-h        = valid-h / invalid-app-str
valid-h         = S *(HEXDIG S HEXDIG S / ellipsis S) S

; app-string b64
b64             = %s"b64" SQUOTE inside-b64 SQUOTE
inside-b64      = valid-b64 / invalid-app-str
valid-b64       = B *b64-4  [ b64-3 / b64-2 ]
b64-4           = 4(b64dig B)
b64-3           = 3(b64dig B) ["="] B
b64-2           = 2(b64dig B) ["=" B "="] B
b64dig          = ALPHA / DIGIT / "-" / "_" / "+" / "/"
B               = *iblank *(hash-comment *iblank)
iblank          = %x0A / %x20  ; Not HT or CR (gone)

; app-string dt
dt              = (%s"dt" / %s"DT") SQUOTE inside-dt SQUOTE
inside-dt       = date-time / invalid-app-str
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset
date-time       = full-date "T" full-time
date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap sec
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]

; app-string ip
ip              = (%s"ip" / %s"IP") SQUOTE inside-ip SQUOTE
inside-ip       = valid-ip / invalid-app-str
valid-ip        = IPaddress ["/" uint]
IPaddress       = IPv4address/ IPv6address

; ABNF from RFC 3986, re-arranged for PEG compatibility:
IPv6address     =                            6( h16 ":" ) ls32
                /                       "::" 5( h16 ":" ) ls32
                / [ h16               ] "::" 4( h16 ":" ) ls32
                / [ h16 *1( ":" h16 ) ] "::" 3( h16 ":" ) ls32
                / [ h16 *2( ":" h16 ) ] "::" 2( h16 ":" ) ls32
                / [ h16 *3( ":" h16 ) ] "::"    h16 ":"   ls32
                / [ h16 *4( ":" h16 ) ] "::"              ls32
                / [ h16 *5( ":" h16 ) ] "::"              h16
                / [ h16 *6( ":" h16 ) ] "::"

h16             = 1*4HEXDIG
ls32            = ( h16 ":" h16 ) / IPv4address
IPv4address     = doctet "." doctet "." doctet "." doctet
doctet          = "25" %x30-35         ; 250-255
                / "2" %x30-34 DIGIT    ; 200-249
                / "1" 2DIGIT           ; 100-199
                / %x31-39 DIGIT        ; 10-99
                / DIGIT                ; 0-9


tstr            = DQUOTE *double-quoted DQUOTE
embedded        = "<<" seq ">>"

array           = "[" spec S [item S *("," S item S) OC] "]"
map             = "{" spec S [kp S *("," S kp S) OC] "}"
kp              = item S ":" S item

; We allow %x09 HT in prose, but not in strings
blank           = %x09 / %x0A / %x0D / %x20
S               = *blank *(comment *blank)
comment         = slash-comment / hash-comment
slash-comment   = "/" *safe-non-slash "/"
hash-comment    = "#" *safe-non-lf LF
safe-non-slash  = safe-unescaped / LF / slash-escaped
safe-non-lf     = safe-unescaped / "/" / hash-escaped
safe-unescaped  =  %x0D ; carriage return
                 / %x20-26   ; omit 0x27 '
                 / %x28-2E   ; omit 0x2F /
                 / %x30-5B   ; omit 0x5C \
                 / %x5D-D7FF ; skip surrogate code points
                 / %xE000-10FFFF
slash-escaped   = "\" ( SQUOTE / "/" / escapable )
hash-escaped    = "\" ( SQUOTE / "\" )
; h'AA#foo'

; optional trailing comma (ignored)
OC              = ["," S]

; check semantically that strings are either all text or all bytes
; note that there must be at least one string to distinguish
streamstring    = "(_" S string S *("," S string S) OC ")"
spec            = ["_" *wordchar]

double-quoted   = unescaped
                / "'"
                / "\" DQUOTE
                / "\" escapable

single-quoted   = unescaped
                / DQUOTE
                / "\" "'"
                / "\" escapable

escapable       = %s"b" ; BS backspace U+0008
                / %s"f" ; FF form feed U+000C
                / %s"n" ; LF line feed U+000A
                / %s"r" ; CR carriage return U+000D
                / %s"t" ; HT horizontal tab U+0009
                / "\"   ; \ backslash (reverse solidus) U+005C
                / (%s"u" hexchar) ;  uXXXX      U+XXXX

hexchar         = "{" (1*"0" [ hexscalar ] / hexscalar) "}"
                / non-surrogate
                / (high-surrogate "\" %s"u" low-surrogate)
non-surrogate   = ((DIGIT / "A"/"B"/"C" / "E"/"F") 3HEXDIG)
                / ("D" ODIGIT 2HEXDIG )
high-surrogate  = "D" ("8"/"9"/"A"/"B") 2HEXDIG
low-surrogate   = "D" ("C"/"D"/"E"/"F") 2HEXDIG
hexscalar       = "10" 4HEXDIG / HEXDIG1 4HEXDIG
                / non-surrogate / 1*3HEXDIG

; Note that no other C0 characters are allowed, including %x09 HT
unescaped       = %x0A ; new line
                / %x0D ; carriage return -- ignored on input
                / %x20-21
                     ; omit 0x22 "
                / %x23-26
                     ; omit 0x27 '
                / %x28-5B
                     ; omit 0x5C \
                / %x5D-D7FF ; skip surrogate code points
                / %xE000-10FFFF

DQUOTE          = %x22    ; " double quote
SQUOTE          = %x27    ; ' single quote
LF              = %x0A    ; LF (Line Feed)

DIGIT           = %x30-39 ; 0-9
DIGIT1          = %x31-39 ; 1-9
ODIGIT          = %x30-37 ; 0-7
BDIGIT          = %x30-31 ; 0-1
HEXDIG          = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
HEXDIG1         = DIGIT1 / "A" / "B" / "C" / "D" / "E" / "F"
; Note: double-quoted strings as in "A" are case-insensitive in ABNF
lcalpha         = %x61-7A ; a-z
lcalnum         = lcalpha / DIGIT
ucalpha         = %x41-5A ; A-Z
ucalnum         = ucalpha / DIGIT
ALPHA           = lcalpha / ucalpha
wordchar        = "_" / ALPHA / DIGIT ; [_a-zA-Z0-9]
